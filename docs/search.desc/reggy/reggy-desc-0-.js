searchState.loadedDescShard("reggy", 0, "A friendly regular expression dialect for text analytics. …\nA <code>reggy</code> pattern represented as an AST\nAn error raised while parsing a <code>reggy</code> pattern\nA match object returned from a <code>Search</code>\nA high-level interface for matching a single <code>reggy</code> pattern\nA compiled searcher for multiple patterns against a stream …\nAn error raised while searching a stream\nA stream search for the provided BufReader\nTry to compile multiple patterns, raising any parse error …\nFind all matching byte spans\nFind all matching substrings\nClear the match state, yielding any pending, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe index of the pattern matched\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over a buffered reader\nReturn the maximum number of bytes this pattern can match\nConvenience function for testing\nCompile from already-parsed ASTs\nCompile one pattern, raising any parse error encountered\nStep through a chunk of text, yielding any matches that …\nStep through a chunk of bytes, yielding any matches that …\nTry to parse a string\nYield any pending, not-definitely-complete matches\nClear the match state\nThe byte span of the match relative to the start of the …\nTranspile to a regex string\nTranspile to a regex AST")